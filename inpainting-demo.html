<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inpainting Demo - Banana Draw</title>
    <style>
        :root {
            --bg-color: #0d0d12;
            --text-primary: #ffffff;
            --accent-blue: #2997ff;
            --panel-bg: rgba(30, 30, 35, 0.6);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Inter', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            margin: 0;
            min-height: 100vh;
        }

        h2 {
            margin-bottom: 30px;
        }

        .editor-container {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-wrapper {
            position: relative;
            width: 512px;
            height: 512px;
            background: #222;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        /* The base image */
        #baseImage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            /* Let clicks pass through to canvas */
        }

        /* The drawing canvas */
        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Toolbar */
        .toolbar {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: var(--panel-bg);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 100px;
        }

        button {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }

        .btn-danger:hover {
            background: rgba(255, 71, 87, 0.3);
        }

        /* Preview Area */
        .preview-area {
            width: 512px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #maskPreview {
            width: 256px;
            height: 256px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 10px;
            background: black;
            /* Check masks usually white on black */
        }
    </style>
</head>

<body>

    <h2>Inpainting Demo (å±€éƒ¨é‡ç»˜æ¼”ç¤º)</h2>

    <div class="editor-container">
        <!-- Main Editor -->
        <div>
            <div class="canvas-wrapper" id="canvasWrapper">
                <!-- Placeholder Image -->
                <img id="baseImage"
                    src="https://images.unsplash.com/photo-1546527868-ccb7ee7dfa6a?q=80&w=2070&auto=format&fit=crop"
                    alt="Base Image">
                <canvas id="maskCanvas" width="512" height="512"></canvas>
            </div>

            <div class="toolbar">
                <div class="tool-group">
                    <label>ç¬”åˆ·å¤§å°:</label>
                    <input type="range" id="brushSize" min="5" max="100" value="40">
                    <span id="brushSizeVal">40px</span>
                </div>

                <div class="tool-group">
                    <button class="btn-secondary" onclick="toggleMode()">åˆ‡æ¢æ©¡çš®/ç”»ç¬”</button>
                    <button class="btn-danger" onclick="clearMask()">æ¸…ç©º</button>
                </div>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button class="btn-primary" style="padding: 12px 40px; font-size: 1.1em;" onclick="generateMask()">ğŸ‘‰
                    ç”Ÿæˆé®ç½©æ•°æ®</button>
            </div>
        </div>

        <!-- Debug/Preview Area -->
        <div class="preview-area">
            <h3>å¹•ååŸç†ï¼šç”Ÿæˆçš„é®ç½© (Mask)</h3>
            <p style="color: #888; margin-bottom: 20px; text-align: center;">
                è¿™æ˜¯å‘é€ç»™ AI çš„æ•°æ®ã€‚<br>
                ç™½è‰² = AIé‡ç»˜åŒºåŸŸ<br>
                é»‘è‰² = ä¿æŒåŸæ ·åŒºåŸŸ
            </p>
            <img id="maskPreview" src="" alt="Mask Preview will appear here">
            <div id="status" style="margin-top: 20px; color: var(--accent-blue);"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('maskCanvas');
        const ctx = canvas.getContext('2d');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeVal = document.getElementById('brushSizeVal');

        let isDrawing = false;
        let brushSize = 40;
        let isEraser = false;

        // Init style
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Brush Size Event
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = e.target.value;
            brushSizeVal.textContent = brushSize + 'px';
            updateCursor();
        });

        // Drawing Events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            // Calculate scale in case canvas is resized by CSS
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            ctx.lineWidth = brushSize;

            if (isEraser) {
                ctx.globalCompositeOperation = 'destination-out'; // Erase
            } else {
                ctx.globalCompositeOperation = 'source-over'; // Draw
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; // Visible mask color (whiteish)
            }

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath(); // Reset path to avoid connecting lines
        }

        function clearMask() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('maskPreview').src = '';
            document.getElementById('status').textContent = 'å·²æ¸…ç©º';
        }

        function toggleMode() {
            isEraser = !isEraser;
            const btn = document.querySelector('.btn-secondary');
            btn.textContent = isEraser ? 'å½“å‰ï¼šæ©¡çš®æ“¦ ğŸ§½' : 'å½“å‰ï¼šç”»ç¬” ğŸ–Œï¸';
            btn.style.background = isEraser ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)';
        }

        function updateCursor() {
            // Simple visual feedback for cursor size could go here
            // For now just letting user see the draw width
        }

        // --- THE MAGIC PART: Converting visible strokes to API Mask ---
        function generateMask() {
            // 1. Create a temporary canvas for the final binary mask
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // 2. Fill Background Black (Keep)
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // 3. Draw the current canvas content onto the temp canvas
            // We force it to be WHITE (Mask area) regardless of what our visible brush color was
            // But since our visible brush is already whiteish, we can just draw the image.

            // However, to ensure it is PURE white #FFFFFF for the AI, we can use composite operations
            // or just ensure our drawing brush was pure white. 

            // Let's use the visible canvas, but force drawn pixels to be #FFFFFF.
            tempCtx.drawImage(canvas, 0, 0);

            // To ensure binary (BW), we can iterate pixels, or just trust the brush was white.
            // A robust way: GlobalCompositeOperation
            tempCtx.globalCompositeOperation = 'source-in';
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Wait, previous step clears background. Better approach:
            // Re-fill black, then draw user strokes as white.
            // Since `canvas` has transparency, we can just draw it on top of black.

            // Precise steps:
            // A. Clear
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // B. Fill Black (Background / Unmasked)
            finalCtx.fillStyle = '#000000';
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

            // C. Draw the user's strokes on top
            // Since user strokes are white (rgba(255,255,255,0.8)), drawing them on black
            // might result in gray. We want Pure White.
            // So we take the alpha channel of user's canvas and make it White.

            finalCtx.drawImage(canvas, 0, 0);

            // Thresholding to ensure binary white (optional but good for AI)
            const imageData = finalCtx.getImageData(0, 0, finalCanvas.width, finalCanvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // If pixel is visible (user drew something), make it WHITE
                // data[0] is R. If > 0 means we drew something.
                if (data[i] > 20) {
                    data[i] = 255;     // R
                    data[i + 1] = 255;   // G
                    data[i + 2] = 255;   // B
                    data[i + 3] = 255;   // Alpha
                } else {
                    // Keep Black
                    data[i] = 0;
                    data[i + 1] = 0;
                    data[i + 2] = 0;
                    data[i + 3] = 255;
                }
            }
            finalCtx.putImageData(imageData, 0, 0);

            // 4. Export
            const dataUrl = finalCanvas.toDataURL('image/png');

            // Display
            document.getElementById('maskPreview').src = dataUrl;
            document.getElementById('status').innerHTML = 'âœ… é®ç½©å·²ç”Ÿæˆ! <br>æ­¤ Base64 å›¾ç‰‡å°†éš API å‘é€ã€‚';
        }
    </script>
</body>

</html>